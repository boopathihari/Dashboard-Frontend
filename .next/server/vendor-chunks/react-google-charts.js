"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-google-charts";
exports.ids = ["vendor-chunks/react-google-charts"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-google-charts/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/react-google-charts/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chart: () => (/* binding */ Chart),\n/* harmony export */   GoogleDataTableColumnRoleType: () => (/* binding */ GoogleDataTableColumnRoleType),\n/* harmony export */   \"default\": () => (/* binding */ Chart)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n/**\n * Hook to load external script.\n * @param src - Source url to load.\n * @param onLoad - Success callback.\n * @param onError - Error callback.\n */ function useLoadScript(src) {\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isSuccess, setIsSuccess] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const onLoad = ()=>{\n        setIsLoading(false);\n        setIsSuccess(true);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!document) {\n            const error = new Error(`[ScriptLoadingError] document not defined when attempting to load ${src}`);\n            setError(error);\n            return;\n        }\n        // Find script tag with same src in DOM.\n        const foundScript = document.querySelector(`script[src=\"${src}\"]`);\n        // Call onLoad if script marked as loaded.\n        if (foundScript?.dataset.loaded) {\n            onLoad();\n            return;\n        }\n        // Create or get existed tag.\n        const script = foundScript || document.createElement(\"script\");\n        // Set src if no script was found.\n        if (!foundScript) {\n            script.src = src;\n        }\n        // Mark script as loaded on load event.\n        const onLoadWithMarker = ()=>{\n            script.dataset.loaded = \"1\";\n            onLoad();\n        };\n        script.addEventListener(\"load\", onLoadWithMarker);\n        script.addEventListener(\"error\", (err)=>{\n            console.error(\"Failed to load script:\", src, err);\n            const error = new Error(`[ScriptLoadingError] Failed to load script: ${src}`);\n            setError(error);\n        });\n        // Add to DOM if not yet added.\n        if (!foundScript) {\n            document.head.append(script);\n        }\n    }, []);\n    return {\n        isLoading,\n        error,\n        isSuccess\n    };\n}\n\nconst isGoogleReady = (google)=>{\n    return google && google.charts;\n};\nconst isGoogleChartsReady = (props, google)=>{\n    const { controls, toolbarItems, getChartEditor } = props;\n    return google && google.charts && google.visualization && google.visualization.ChartWrapper && google.visualization.Dashboard && (!controls || google.visualization.ChartWrapper) && (!getChartEditor || google.visualization.ChartEditor) && (!toolbarItems || google.visualization.drawToolbar);\n};\nconst getGoogleInstanceFromWindow = (props)=>{\n    // @ts-expect-error Getting object from global namespace.\n    const google = window.google;\n    return google;\n};\n/**\n * Hook to load Google Charts JS API.\n * @param params - Load parameters.\n * @param [params.chartVersion] - Chart version to load.\n * @param [params.chartPackages] - Packages to load.\n * @param [params.chartLanguage] - Languages to load.\n * @param [params.mapsApiKey] - Google Maps api key.\n * @returns\n */ function useLoadGoogleCharts(props) {\n    const { chartVersion = \"current\", chartPackages = [\n        \"corechart\",\n        \"controls\"\n    ], chartLanguage = \"en\", mapsApiKey } = props;\n    const [googleCharts, setGoogleCharts] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [scriptInitializationError, setScriptInitializationError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [googleChartsInitializationError, setGoogleChartsInitializationError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const { isLoading, error: scriptLoadingError, isSuccess } = useLoadScript(props.chartLoaderScriptUrl || \"https://www.gstatic.com/charts/loader.js\");\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!isSuccess) {\n            return;\n        }\n        const google = getGoogleInstanceFromWindow();\n        if (!isGoogleReady(google)) {\n            const error = new Error(\"[ScriptInitializationError] Script loaded but Google not attached to window.\");\n            setScriptInitializationError(error);\n            return;\n        }\n        if (isGoogleChartsReady(props, google)) {\n            setGoogleCharts(google);\n            return;\n        }\n        google.charts.load(chartVersion, {\n            packages: chartPackages,\n            language: chartLanguage,\n            mapsApiKey\n        });\n        google.charts.setOnLoadCallback(()=>{\n            if (!isGoogleChartsReady(props, google)) {\n                const error = new Error(\"[GoogleChartsInitializationError] Google Charts not ready after load callback.\");\n                console.error(error);\n                setGoogleChartsInitializationError(error);\n                return;\n            }\n            setGoogleCharts(google);\n        });\n    }, [\n        isSuccess\n    ]);\n    return {\n        error: scriptLoadingError || scriptInitializationError || googleChartsInitializationError,\n        isLoading,\n        google: googleCharts\n    };\n}\n\nconst chartDefaultProps = {\n    // <DEPRECATED_PROPS>\n    legend_toggle: false,\n    // </DEPRECATED_PROPS>\n    options: {},\n    legendToggle: false,\n    getChartWrapper: ()=>{},\n    spreadSheetQueryParameters: {\n        headers: 1,\n        gid: 1\n    },\n    rootProps: {},\n    chartWrapperParams: {},\n    chartLoaderScriptUrl: \"https://www.gstatic.com/charts/loader.js\"\n};\n\nconst GoogleChartControls = (props)=>{\n    const { isReady, chartControls, filter } = props;\n    if (!isReady || !chartControls || !chartControls?.length) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, chartControls.filter((param)=>{\n        let { controlProp, control } = param;\n        return filter ? filter({\n            control,\n            controlProp\n        }) : true;\n    }).map((param)=>{\n        let { control } = param;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            key: control.getContainerId(),\n            id: control.getContainerId()\n        });\n    }));\n};\n\nlet uniqueID = 0;\nconst generateUniqueID = ()=>{\n    uniqueID += 1;\n    return `reactgooglegraph-${uniqueID}`;\n};\n\n/**\n * An internal helper class for creating and managing Google Charts controls.\n * Offers high-level methods to interact with the Google Chart Controls.\n */ class GoogleChartControlsInternal {\n    /**\n   * Initialize the controls once chart is ready\n   */ static initializeControls = (googleChartControls)=>{\n        for(let i = 0; i < googleChartControls.length; i += 1){\n            const { controlType, options, controlWrapperParams } = googleChartControls[i].controlProp;\n            if (controlWrapperParams && \"state\" in controlWrapperParams) {\n                googleChartControls[i].control.setState(controlWrapperParams[\"state\"]);\n            }\n            googleChartControls[i].control.setOptions(options);\n            googleChartControls[i].control.setControlType(controlType);\n        }\n    };\n    /**\n   * listen to the control events (ready, statechange, error) specified in the controlEvents prop\n   */ static listenToControlEvents = (googleChartControls, props)=>{\n        const { google } = props;\n        return googleChartControls.flatMap((chartControl)=>{\n            const { control, controlProp } = chartControl;\n            const { controlEvents = [] } = controlProp;\n            return controlEvents.map((event)=>{\n                const { callback, eventName } = event;\n                return google.visualization.events.addListener(control, eventName, function() {\n                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                        args[_key] = arguments[_key];\n                    }\n                    callback({\n                        chartWrapper: null,\n                        controlWrapper: control,\n                        props: props,\n                        google: google,\n                        eventArgs: args\n                    });\n                });\n            });\n        });\n    };\n    /**\n   * If controlID is not provided, generate a unique controlID\n   */ static createControlId = (id)=>{\n        let controlID;\n        if (typeof id === \"undefined\") {\n            controlID = `googlechart-control-${generateUniqueID()}`;\n        } else {\n            controlID = id;\n        }\n        return controlID;\n    };\n    /**\n   * Map the control props to Google Chart Controls\n   */ static createChartControls = (props)=>{\n        const { controls, google } = props;\n        if (!controls) {\n            return null;\n        }\n        return controls.map((control, i)=>{\n            const { controlID: controlIDMaybe, controlType, options: controlOptions, controlWrapperParams } = control;\n            const controlID = this.createControlId(controlIDMaybe);\n            return {\n                controlProp: control,\n                control: new google.visualization.ControlWrapper({\n                    containerId: controlID,\n                    controlType,\n                    options: controlOptions,\n                    ...controlWrapperParams\n                })\n            };\n        });\n    };\n    static addControls = (props)=>{\n        const { chartWrapper, chartDashboard } = props;\n        const googleChartControls = this.createChartControls(props);\n        if (!googleChartControls || !chartDashboard || !chartWrapper) {\n            return null;\n        }\n        chartDashboard.bind(googleChartControls.map((param)=>{\n            let { control } = param;\n            return control;\n        }), chartWrapper);\n        this.initializeControls(googleChartControls);\n        return googleChartControls;\n    };\n}\n\nconst useCreateChartControls = (controls)=>{\n    const [chartControls, setChartControls] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const controlAndProp = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!chartControls || !controls) return null;\n        return controls.map((controlProp, i)=>{\n            const control = chartControls[i];\n            return control ? {\n                controlProp,\n                control\n            } : undefined;\n        }).flatMap((controlAndProp)=>controlAndProp ? [\n                controlAndProp\n            ] : []);\n    }, [\n        chartControls,\n        controls\n    ]);\n    return [\n        controlAndProp,\n        setChartControls\n    ];\n};\nconst useListenToControlEvents = (chartControls, props)=>{\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        const listeners = GoogleChartControlsInternal.listenToControlEvents(chartControls ?? [], props);\n        return ()=>{\n            listeners.forEach((listener)=>{\n                props.google.visualization.events.removeListener(listener);\n            });\n        };\n    }, [\n        chartControls,\n        props\n    ]);\n};\nconst useChartControls = (props)=>{\n    const [chartControls, setChartControls] = useCreateChartControls(props.controls);\n    useListenToControlEvents(chartControls ?? [], props);\n    /**\n   * Render the container divs for the controls\n   */ const renderControl = (filter)=>{\n        const { chartWrapper, chartDashboard } = props;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(GoogleChartControls, {\n            ...props,\n            isReady: Boolean(chartWrapper && chartDashboard),\n            chartControls: chartControls,\n            filter: filter\n        });\n    };\n    return {\n        addControls: (props)=>{\n            const controls = GoogleChartControlsInternal.addControls(props);\n            setChartControls(controls?.map((control)=>control.control) ?? null);\n        },\n        renderControl\n    };\n};\n\nconst useChartId = (props)=>{\n    const chartIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const getChartId = ()=>{\n        const { graphID, graph_id } = props;\n        const chartIdFromProps = graphID || graph_id;\n        let currentChartId;\n        if (chartIdFromProps) {\n            currentChartId = chartIdFromProps;\n        } else {\n            currentChartId = chartIdRef.current || generateUniqueID();\n        }\n        chartIdRef.current = currentChartId;\n        return chartIdRef.current;\n    };\n    const chartId = getChartId();\n    return {\n        chartId\n    };\n};\n\nconst DEFAULT_CHART_COLORS = [\n    \"#3366CC\",\n    \"#DC3912\",\n    \"#FF9900\",\n    \"#109618\",\n    \"#990099\",\n    \"#3B3EAC\",\n    \"#0099C6\",\n    \"#DD4477\",\n    \"#66AA00\",\n    \"#B82E2E\",\n    \"#316395\",\n    \"#994499\",\n    \"#22AA99\",\n    \"#AAAA11\",\n    \"#6633CC\",\n    \"#E67300\",\n    \"#8B0707\",\n    \"#329262\",\n    \"#5574A6\",\n    \"#3B3EAC\"\n];\n\nconst loadDataTableFromSpreadSheet = async function(googleViz, spreadSheetUrl) {\n    let urlParams = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    return new Promise((resolve, reject)=>{\n        const headers = `${urlParams.headers ? `headers=${urlParams.headers}` : `headers=0`}`;\n        const queryString = `${urlParams.query ? `&tq=${encodeURIComponent(urlParams.query)}` : ``}`;\n        const gid = `${urlParams.gid ? `&gid=${urlParams.gid}` : \"\"}`;\n        const sheet = `${urlParams.sheet ? `&sheet=${urlParams.sheet}` : \"\"}`;\n        const access_token = `${urlParams.access_token ? `&access_token=${urlParams.access_token}` : \"\"}`;\n        const urlQueryString = `${headers}${gid}${sheet}${queryString}${access_token}`;\n        const urlToSpreadSheet = `${spreadSheetUrl}/gviz/tq?${urlQueryString}`; //&tq=${queryString}`;\n        const query = new googleViz.visualization.Query(urlToSpreadSheet);\n        query.send((response)=>{\n            if (response.isError()) {\n                reject(`Error in query:  ${response.getMessage()} ${response.getDetailedMessage()}`);\n            } else {\n                resolve(response.getDataTable());\n            }\n        });\n    });\n};\n\nconst GRAY_COLOR = \"#CCCCCC\";\n/**\n * An internal helper class around the Google Chart API.\n * Offers high-level methods to interact with the Google Chart API.\n */ class GoogleChartInternal {\n    static grayOutHiddenColumnsLabel = (props, hiddenColumns)=>{\n        const { googleChartWrapper, options } = props;\n        if (!googleChartWrapper) {\n            console.error(\"googleChartWrapper is not defined\");\n            return;\n        }\n        const dataTable = googleChartWrapper.getDataTable();\n        if (!dataTable) return;\n        const columnCount = dataTable.getNumberOfColumns();\n        const hasAHiddenColumn = hiddenColumns.length > 0;\n        if (hasAHiddenColumn === false) return;\n        const colors = Array.from({\n            length: columnCount - 1\n        }).map((_dontcare, i)=>{\n            const columnID = this.getColumnId(dataTable, i + 1);\n            if (hiddenColumns.includes(columnID)) {\n                return GRAY_COLOR;\n            } else if (options && options.colors) {\n                return options.colors[i];\n            } else {\n                return DEFAULT_CHART_COLORS[i];\n            }\n        });\n        googleChartWrapper.setOptions({\n            ...options,\n            colors\n        });\n        googleChartWrapper.draw();\n    };\n    /**\n   * Listens to user clicking on the legend to toggle the visibility of a column.\n   * When a user clicks on a legend item, the column id is added to / removed from the hiddenColumns state.\n   */ static listenToLegendToggle = (props, hiddenColumnsState)=>{\n        const [hiddenColumns, setHiddenColumns] = hiddenColumnsState;\n        const { google, googleChartWrapper } = props;\n        if (!googleChartWrapper) {\n            console.error(\"googleChartWrapper is not defined\");\n            return;\n        }\n        return google.visualization.events.addListener(googleChartWrapper, \"select\", ()=>{\n            const chart = googleChartWrapper.getChart();\n            const selection = chart.getSelection();\n            const dataTable = googleChartWrapper.getDataTable();\n            if (selection.length === 0 || // We want to listen to when a whole row is selected. This is the case only when row === null\n            selection[0].row !== null || !dataTable) {\n                return;\n            }\n            const columnIndex = selection[0].column;\n            const columnID = this.getColumnId(dataTable, columnIndex);\n            // If the column is hidden remove it from state, otherwise add it\n            if (hiddenColumns?.includes(columnID)) {\n                setHiddenColumns((state)=>[\n                        ...state.filter((colID)=>colID !== columnID)\n                    ]);\n            } else {\n                setHiddenColumns((state)=>[\n                        ...state,\n                        columnID\n                    ]);\n            }\n        });\n    };\n    /**\n   * (Re-)Draw a Google Chart with the given data, options, and chart type.\n   */ static draw = async (props)=>{\n        const { data, diffdata, rows, columns, options, chartType, formatters, spreadSheetUrl, spreadSheetQueryParameters, googleChartDashboard, googleChartWrapper, google, hiddenColumns, legendToggle, legend_toggle } = props;\n        if (!googleChartWrapper) {\n            console.error(\"draw was called with googleChartWrapper = null\");\n            return;\n        }\n        let dataTable;\n        let chartDiff = null;\n        if (diffdata) {\n            const oldData = google.visualization.arrayToDataTable(diffdata.old);\n            const newData = google.visualization.arrayToDataTable(diffdata.new);\n            chartDiff = google.visualization[chartType].prototype.computeDiff(oldData, newData);\n        }\n        if (data) {\n            if (Array.isArray(data)) {\n                dataTable = google.visualization.arrayToDataTable(data);\n            } else {\n                dataTable = new google.visualization.DataTable(data);\n            }\n        } else if (rows && columns) {\n            dataTable = google.visualization.arrayToDataTable([\n                columns,\n                ...rows\n            ]);\n        } else if (spreadSheetUrl) {\n            dataTable = await loadDataTableFromSpreadSheet(google, spreadSheetUrl, spreadSheetQueryParameters);\n        } else {\n            dataTable = google.visualization.arrayToDataTable([]);\n        }\n        const columnCount = dataTable.getNumberOfColumns();\n        const viewColumns = Array(columnCount).fill(0).map((_c, i)=>{\n            const columnID = this.getColumnId(dataTable, i);\n            if (hiddenColumns.includes(columnID)) {\n                return {\n                    label: dataTable.getColumnLabel(i),\n                    type: dataTable.getColumnType(i),\n                    calc: ()=>null\n                };\n            } else {\n                return i;\n            }\n        });\n        const chart = googleChartWrapper.getChart();\n        if (googleChartWrapper.getChartType() === \"Timeline\") {\n            chart && chart.clearChart();\n        }\n        googleChartWrapper.setChartType(chartType);\n        googleChartWrapper.setOptions(options || {});\n        const viewTable = new google.visualization.DataView(dataTable);\n        viewTable.setColumns(viewColumns);\n        googleChartWrapper.setDataTable(viewTable);\n        googleChartWrapper.draw();\n        if (googleChartDashboard) {\n            googleChartDashboard.draw(dataTable);\n        }\n        if (chartDiff) {\n            googleChartWrapper.setDataTable(chartDiff);\n            googleChartWrapper.draw();\n        }\n        if (formatters) {\n            this.applyFormatters({\n                dataTable,\n                formatters,\n                google\n            });\n            googleChartWrapper.setDataTable(dataTable);\n            googleChartWrapper.draw();\n        }\n        if (legendToggle === true || legend_toggle === true) {\n            this.grayOutHiddenColumnsLabel(props, hiddenColumns);\n        }\n        return;\n    };\n    /**\n   * Get the column ID of a column in a GoogleDataTable.\n   * If the column has an ID, return the ID, otherwise return the label.\n   */ static getColumnId = (dataTable, columnIndex)=>{\n        return dataTable.getColumnId(columnIndex) || dataTable.getColumnLabel(columnIndex);\n    };\n    /**\n   * Apply Chart Formatters passed under the formatters prop to the GoogleDataTable\n   */ static applyFormatters = (param)=>{\n        let { dataTable, formatters, google } = param;\n        for (let formatter of formatters){\n            switch(formatter.type){\n                case \"ArrowFormat\":\n                    {\n                        const vizFormatter = new google.visualization.ArrowFormat(formatter.options);\n                        vizFormatter.format(dataTable, formatter.column);\n                        return;\n                    }\n                case \"BarFormat\":\n                    {\n                        const vizFormatter = new google.visualization.BarFormat(formatter.options);\n                        vizFormatter.format(dataTable, formatter.column);\n                        return;\n                    }\n                case \"ColorFormat\":\n                    {\n                        const vizFormatter = new google.visualization.ColorFormat(formatter.options);\n                        const { ranges } = formatter;\n                        if (ranges) {\n                            for (let range of ranges){\n                                vizFormatter.addRange(...range);\n                            }\n                        }\n                        vizFormatter.format(dataTable, formatter.column);\n                        return;\n                    }\n                case \"DateFormat\":\n                    {\n                        const vizFormatter = new google.visualization.DateFormat(formatter.options);\n                        vizFormatter.format(dataTable, formatter.column);\n                        return;\n                    }\n                case \"NumberFormat\":\n                    {\n                        const vizFormatter = new google.visualization.NumberFormat(formatter.options);\n                        vizFormatter.format(dataTable, formatter.column);\n                        return;\n                    }\n                case \"PatternFormat\":\n                    {\n                        const vizFormatter = new google.visualization.PatternFormat(formatter.options);\n                        vizFormatter.format(dataTable, formatter.column);\n                        return;\n                    }\n                default:\n                    {\n                        console.warn(`Unknown formatter type: ${formatter.type}`);\n                        return;\n                    }\n            }\n        }\n    };\n}\n\nconst useGoogleChartDataTable = (props)=>{\n    const { google, googleChartWrapper, googleChartDashboard } = props;\n    const [hiddenColumns, setHiddenColumns] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]);\n    // Re-draw the chart when hiddenColumns change\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!googleChartWrapper) {\n            return;\n        }\n        GoogleChartInternal.draw({\n            ...props,\n            hiddenColumns,\n            googleChartWrapper,\n            googleChartDashboard,\n            google\n        });\n    }, [\n        hiddenColumns,\n        props.data,\n        props.rows,\n        props.columns,\n        props.options,\n        props.chartLoaderScriptUrl,\n        props.chartType,\n        props.formatters,\n        props.spreadSheetUrl,\n        props.spreadSheetQueryParameters,\n        props.legendToggle,\n        props.legend_toggle\n    ]);\n    // Re-draw the chart when the window is resized\n    const onResize = ()=>{\n        const { googleChartWrapper } = props;\n        if (!googleChartWrapper) {\n            return;\n        }\n        googleChartWrapper.draw();\n    };\n    // Draw the chart when the google charts wrapper is ready and when the hiddenColumns change\n    const initialize = (googleChartWrapper)=>{\n        const listeners = [];\n        const { legendToggle, legend_toggle } = props;\n        GoogleChartInternal.draw({\n            ...props,\n            hiddenColumns,\n            googleChartWrapper,\n            googleChartDashboard,\n            google\n        });\n        window.addEventListener(\"resize\", onResize);\n        if (legend_toggle || legendToggle) {\n            const listener = GoogleChartInternal.listenToLegendToggle(props, [\n                hiddenColumns,\n                setHiddenColumns\n            ]);\n            if (listener) listeners.push(listener);\n        }\n        return listeners;\n    };\n    // Remove event listeners and clear the chart when the component is unmounted\n    const destroy = (googleChartWrapper, listeners)=>{\n        window.removeEventListener(\"resize\", onResize);\n        listeners.forEach((listener)=>{\n            google.visualization.events.removeListener(listener);\n        });\n        if (googleChartWrapper.getChartType() === \"Timeline\") {\n            googleChartWrapper.getChart() && googleChartWrapper.getChart().clearChart();\n        }\n    };\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!googleChartWrapper) {\n            return;\n        }\n        const listeners = initialize(googleChartWrapper);\n        return ()=>{\n            destroy(googleChartWrapper, listeners);\n        };\n    }, [\n        googleChartWrapper,\n        initialize,\n        destroy\n    ]);\n};\n\nconst listenToEvents = (props)=>{\n    const { chartEvents, google, googleChartWrapper } = props;\n    if (!chartEvents) {\n        return;\n    }\n    if (!googleChartWrapper) {\n        console.warn(\"listenToEvents was called before chart wrapper ready.\");\n        return;\n    }\n    return chartEvents.map((param)=>{\n        let { eventName, callback } = param;\n        return google.visualization.events.addListener(googleChartWrapper, eventName, function() {\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            callback({\n                chartWrapper: googleChartWrapper,\n                props,\n                google: google,\n                eventArgs: args\n            });\n        });\n    });\n};\nconst useGoogleChartEvents = (props)=>{\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!props.googleChartWrapper) return;\n        const listeners = listenToEvents(props);\n        return ()=>{\n            listeners?.forEach((listener)=>{\n                props.google.visualization.events.removeListener(listener);\n            });\n        };\n    }, [\n        props\n    ]);\n};\n\nconst GoogleChart = (props)=>{\n    const [googleChartWrapper, setGoogleChartWrapper] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    // const [isReady, setIsReady] = React.useState<boolean>(false);\n    const [googleChartDashboard, setGoogleChartDashboard] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const { addControls, renderControl } = useChartControls({\n        ...props,\n        chartDashboard: googleChartDashboard,\n        chartWrapper: googleChartWrapper\n    });\n    useGoogleChartEvents({\n        ...props,\n        googleChartWrapper\n    });\n    const { chartId } = useChartId(props);\n    const dashboardRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const toolbarRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        const { options, google, chartType, chartWrapperParams, toolbarItems, getChartEditor, getChartWrapper, onLoad } = props;\n        const chartConfig = {\n            chartType,\n            options,\n            containerId: chartId,\n            ...chartWrapperParams\n        };\n        // Create ChartWrapper instance, pass it to the user and store it in state\n        const chartWrapper = new google.visualization.ChartWrapper(chartConfig);\n        chartWrapper.setOptions(options || {});\n        getChartWrapper?.(chartWrapper, google);\n        // Create Dashboard instance, needed for controls\n        const chartDashboard = new google.visualization.Dashboard(dashboardRef.current);\n        // Create toolbar if needed\n        if (toolbarItems) {\n            google.visualization.drawToolbar(toolbarRef.current, toolbarItems);\n        }\n        // Create ChartEditor instance if needed and pass it to the user\n        let chartEditor = null;\n        if (getChartEditor) {\n            chartEditor = new google.visualization.ChartEditor();\n            getChartEditor({\n                chartEditor,\n                chartWrapper,\n                google\n            });\n        }\n        // Create and add controls to the chart / dashboard\n        addControls({\n            ...props,\n            chartDashboard,\n            chartWrapper\n        });\n        setGoogleChartWrapper(chartWrapper);\n        setGoogleChartDashboard(chartDashboard);\n        onLoad?.(google, {\n            google,\n            chartWrapper,\n            chartEditor,\n            chartDashboard\n        });\n    }, []);\n    useGoogleChartDataTable({\n        ...props,\n        googleChartWrapper,\n        googleChartDashboard\n    });\n    const renderChart = ()=>{\n        const { width, height, options, style, className, rootProps, google } = props;\n        const divStyle = {\n            height: height || options && options.height,\n            width: width || options && options.width,\n            ...style\n        };\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            id: chartId,\n            style: divStyle,\n            className: className,\n            ...rootProps\n        });\n    };\n    const renderToolBar = ()=>{\n        if (!props.toolbarItems) return null;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            ref: toolbarRef\n        });\n    };\n    const { width, height, options, style } = props;\n    const divStyle = {\n        height: height || options && options.height,\n        width: width || options && options.width,\n        ...style\n    };\n    // If render prop is provided, give the user full control over the rendering by passing renderChart, renderControl and renderToolbar functions\n    if (props.render) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            ref: dashboardRef,\n            style: divStyle\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            ref: toolbarRef,\n            id: \"toolbar\"\n        }), props.render({\n            renderChart,\n            renderControl,\n            renderToolbar: renderToolBar\n        }));\n    } else {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            ref: dashboardRef,\n            style: divStyle\n        }, renderControl((param)=>{\n            let { controlProp } = param;\n            return controlProp.controlPosition !== \"bottom\";\n        }), renderChart(), renderControl((param)=>{\n            let { controlProp } = param;\n            return controlProp.controlPosition === \"bottom\";\n        }), renderToolBar());\n    }\n};\n\nconst ChartContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(chartDefaultProps);\nconst ContextProvider = (param)=>{\n    let { children, value } = param;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ChartContext.Provider, {\n        value: value\n    }, children);\n};\n\n/**\n * Loads Google Charts JS and renders the GoogleChart component.\n */ const ChartView = (props)=>{\n    const { google, isLoading, error } = useLoadGoogleCharts(props);\n    if (isLoading) {\n        return props.loader ?? null;\n    }\n    if (error) {\n        return props.errorElement ?? null;\n    }\n    if (google) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(GoogleChart, {\n            google: google,\n            ...props\n        });\n    }\n    return null;\n};\n/**\n * Updates the context with the props and renders ChartView.\n */ const Chart = (userProps)=>{\n    const props = {\n        ...chartDefaultProps,\n        ...userProps\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ContextProvider, {\n        value: props\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ChartView, props));\n};\n\n// Complete Google Charts Type Definition : https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/google.visualization/index.d.ts\nvar GoogleDataTableColumnRoleType;\n(function(GoogleDataTableColumnRoleType) {\n    GoogleDataTableColumnRoleType[\"annotation\"] = \"annotation\";\n    GoogleDataTableColumnRoleType[\"annotationText\"] = \"annotationText\";\n    GoogleDataTableColumnRoleType[\"certainty\"] = \"certainty\";\n    GoogleDataTableColumnRoleType[\"emphasis\"] = \"emphasis\";\n    GoogleDataTableColumnRoleType[\"interval\"] = \"interval\";\n    GoogleDataTableColumnRoleType[\"scope\"] = \"scope\";\n    GoogleDataTableColumnRoleType[\"style\"] = \"style\";\n    GoogleDataTableColumnRoleType[\"tooltip\"] = \"tooltip\";\n    GoogleDataTableColumnRoleType[\"domain\"] = \"domain\";\n})(GoogleDataTableColumnRoleType || (GoogleDataTableColumnRoleType = {}));\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ29vZ2xlLWNoYXJ0cy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0I7QUFDNkI7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywrQ0FBUTtBQUM5Qyw4QkFBOEIsK0NBQVE7QUFDdEMsc0NBQXNDLCtDQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnREFBUztBQUNiO0FBQ0EseUdBQXlHLElBQUk7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsSUFBSTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixJQUFJO0FBQ3ZGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUNBQXlDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsNENBQTRDLCtDQUFRO0FBQ3BELHNFQUFzRSwrQ0FBUTtBQUM5RSxrRkFBa0YsK0NBQVE7QUFDMUYsWUFBWSxrREFBa0Q7QUFDOUQsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQSw2QkFBNkIsZ0RBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnREFBbUI7QUFDaEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxZQUFZLGdDQUFnQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnREFBbUI7QUFDaEQ7QUFDQTtBQUNBLFNBQVMsZ0JBQWdCLGdEQUFtQjtBQUM1QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ04sNkJBQTZCLGdEQUFtQjtBQUNoRDtBQUNBO0FBQ0EsU0FBUztBQUNULGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0EsU0FBUztBQUNULGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsbUNBQW1DLGdEQUFtQjtBQUN0RDtBQUNBLFVBQVUsa0JBQWtCO0FBQzVCLHlCQUF5QixnREFBbUI7QUFDNUM7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0RBQTRCO0FBQ3pEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0RBQTRCO0FBQ3JEO0FBQ0EsS0FBSyxnQkFBZ0IsZ0RBQTRCO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0VBQXNFOztBQUVMO0FBQ2xFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdvb2dsZS1jaGFydHMvZGlzdC9pbmRleC5qcz9hOWQwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdF9fZGVmYXVsdCwgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIEhvb2sgdG8gbG9hZCBleHRlcm5hbCBzY3JpcHQuXG4gKiBAcGFyYW0gc3JjIC0gU291cmNlIHVybCB0byBsb2FkLlxuICogQHBhcmFtIG9uTG9hZCAtIFN1Y2Nlc3MgY2FsbGJhY2suXG4gKiBAcGFyYW0gb25FcnJvciAtIEVycm9yIGNhbGxiYWNrLlxuICovIGZ1bmN0aW9uIHVzZUxvYWRTY3JpcHQoc3JjKSB7XG4gICAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICAgIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgW2lzU3VjY2Vzcywgc2V0SXNTdWNjZXNzXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBvbkxvYWQgPSAoKT0+e1xuICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICBzZXRJc1N1Y2Nlc3ModHJ1ZSk7XG4gICAgfTtcbiAgICB1c2VFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKCFkb2N1bWVudCkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYFtTY3JpcHRMb2FkaW5nRXJyb3JdIGRvY3VtZW50IG5vdCBkZWZpbmVkIHdoZW4gYXR0ZW1wdGluZyB0byBsb2FkICR7c3JjfWApO1xuICAgICAgICAgICAgc2V0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgc2NyaXB0IHRhZyB3aXRoIHNhbWUgc3JjIGluIERPTS5cbiAgICAgICAgY29uc3QgZm91bmRTY3JpcHQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBzY3JpcHRbc3JjPVwiJHtzcmN9XCJdYCk7XG4gICAgICAgIC8vIENhbGwgb25Mb2FkIGlmIHNjcmlwdCBtYXJrZWQgYXMgbG9hZGVkLlxuICAgICAgICBpZiAoZm91bmRTY3JpcHQ/LmRhdGFzZXQubG9hZGVkKSB7XG4gICAgICAgICAgICBvbkxvYWQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgb3IgZ2V0IGV4aXN0ZWQgdGFnLlxuICAgICAgICBjb25zdCBzY3JpcHQgPSBmb3VuZFNjcmlwdCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAvLyBTZXQgc3JjIGlmIG5vIHNjcmlwdCB3YXMgZm91bmQuXG4gICAgICAgIGlmICghZm91bmRTY3JpcHQpIHtcbiAgICAgICAgICAgIHNjcmlwdC5zcmMgPSBzcmM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFyayBzY3JpcHQgYXMgbG9hZGVkIG9uIGxvYWQgZXZlbnQuXG4gICAgICAgIGNvbnN0IG9uTG9hZFdpdGhNYXJrZXIgPSAoKT0+e1xuICAgICAgICAgICAgc2NyaXB0LmRhdGFzZXQubG9hZGVkID0gXCIxXCI7XG4gICAgICAgICAgICBvbkxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2NyaXB0LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIG9uTG9hZFdpdGhNYXJrZXIpO1xuICAgICAgICBzY3JpcHQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIChlcnIpPT57XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGxvYWQgc2NyaXB0OlwiLCBzcmMsIGVycik7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgW1NjcmlwdExvYWRpbmdFcnJvcl0gRmFpbGVkIHRvIGxvYWQgc2NyaXB0OiAke3NyY31gKTtcbiAgICAgICAgICAgIHNldEVycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFkZCB0byBET00gaWYgbm90IHlldCBhZGRlZC5cbiAgICAgICAgaWYgKCFmb3VuZFNjcmlwdCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmQoc2NyaXB0KTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc0xvYWRpbmcsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBpc1N1Y2Nlc3NcbiAgICB9O1xufVxuXG5jb25zdCBpc0dvb2dsZVJlYWR5ID0gKGdvb2dsZSk9PntcbiAgICByZXR1cm4gZ29vZ2xlICYmIGdvb2dsZS5jaGFydHM7XG59O1xuY29uc3QgaXNHb29nbGVDaGFydHNSZWFkeSA9IChwcm9wcywgZ29vZ2xlKT0+e1xuICAgIGNvbnN0IHsgY29udHJvbHMsIHRvb2xiYXJJdGVtcywgZ2V0Q2hhcnRFZGl0b3IgfSA9IHByb3BzO1xuICAgIHJldHVybiBnb29nbGUgJiYgZ29vZ2xlLmNoYXJ0cyAmJiBnb29nbGUudmlzdWFsaXphdGlvbiAmJiBnb29nbGUudmlzdWFsaXphdGlvbi5DaGFydFdyYXBwZXIgJiYgZ29vZ2xlLnZpc3VhbGl6YXRpb24uRGFzaGJvYXJkICYmICghY29udHJvbHMgfHwgZ29vZ2xlLnZpc3VhbGl6YXRpb24uQ2hhcnRXcmFwcGVyKSAmJiAoIWdldENoYXJ0RWRpdG9yIHx8IGdvb2dsZS52aXN1YWxpemF0aW9uLkNoYXJ0RWRpdG9yKSAmJiAoIXRvb2xiYXJJdGVtcyB8fCBnb29nbGUudmlzdWFsaXphdGlvbi5kcmF3VG9vbGJhcik7XG59O1xuY29uc3QgZ2V0R29vZ2xlSW5zdGFuY2VGcm9tV2luZG93ID0gKHByb3BzKT0+e1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgR2V0dGluZyBvYmplY3QgZnJvbSBnbG9iYWwgbmFtZXNwYWNlLlxuICAgIGNvbnN0IGdvb2dsZSA9IHdpbmRvdy5nb29nbGU7XG4gICAgcmV0dXJuIGdvb2dsZTtcbn07XG4vKipcbiAqIEhvb2sgdG8gbG9hZCBHb29nbGUgQ2hhcnRzIEpTIEFQSS5cbiAqIEBwYXJhbSBwYXJhbXMgLSBMb2FkIHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0gW3BhcmFtcy5jaGFydFZlcnNpb25dIC0gQ2hhcnQgdmVyc2lvbiB0byBsb2FkLlxuICogQHBhcmFtIFtwYXJhbXMuY2hhcnRQYWNrYWdlc10gLSBQYWNrYWdlcyB0byBsb2FkLlxuICogQHBhcmFtIFtwYXJhbXMuY2hhcnRMYW5ndWFnZV0gLSBMYW5ndWFnZXMgdG8gbG9hZC5cbiAqIEBwYXJhbSBbcGFyYW1zLm1hcHNBcGlLZXldIC0gR29vZ2xlIE1hcHMgYXBpIGtleS5cbiAqIEByZXR1cm5zXG4gKi8gZnVuY3Rpb24gdXNlTG9hZEdvb2dsZUNoYXJ0cyhwcm9wcykge1xuICAgIGNvbnN0IHsgY2hhcnRWZXJzaW9uID0gXCJjdXJyZW50XCIsIGNoYXJ0UGFja2FnZXMgPSBbXG4gICAgICAgIFwiY29yZWNoYXJ0XCIsXG4gICAgICAgIFwiY29udHJvbHNcIlxuICAgIF0sIGNoYXJ0TGFuZ3VhZ2UgPSBcImVuXCIsIG1hcHNBcGlLZXkgfSA9IHByb3BzO1xuICAgIGNvbnN0IFtnb29nbGVDaGFydHMsIHNldEdvb2dsZUNoYXJ0c10gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBbc2NyaXB0SW5pdGlhbGl6YXRpb25FcnJvciwgc2V0U2NyaXB0SW5pdGlhbGl6YXRpb25FcnJvcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBbZ29vZ2xlQ2hhcnRzSW5pdGlhbGl6YXRpb25FcnJvciwgc2V0R29vZ2xlQ2hhcnRzSW5pdGlhbGl6YXRpb25FcnJvcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCB7IGlzTG9hZGluZywgZXJyb3I6IHNjcmlwdExvYWRpbmdFcnJvciwgaXNTdWNjZXNzIH0gPSB1c2VMb2FkU2NyaXB0KHByb3BzLmNoYXJ0TG9hZGVyU2NyaXB0VXJsIHx8IFwiaHR0cHM6Ly93d3cuZ3N0YXRpYy5jb20vY2hhcnRzL2xvYWRlci5qc1wiKTtcbiAgICB1c2VFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKCFpc1N1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBnb29nbGUgPSBnZXRHb29nbGVJbnN0YW5jZUZyb21XaW5kb3coKTtcbiAgICAgICAgaWYgKCFpc0dvb2dsZVJlYWR5KGdvb2dsZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwiW1NjcmlwdEluaXRpYWxpemF0aW9uRXJyb3JdIFNjcmlwdCBsb2FkZWQgYnV0IEdvb2dsZSBub3QgYXR0YWNoZWQgdG8gd2luZG93LlwiKTtcbiAgICAgICAgICAgIHNldFNjcmlwdEluaXRpYWxpemF0aW9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0dvb2dsZUNoYXJ0c1JlYWR5KHByb3BzLCBnb29nbGUpKSB7XG4gICAgICAgICAgICBzZXRHb29nbGVDaGFydHMoZ29vZ2xlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBnb29nbGUuY2hhcnRzLmxvYWQoY2hhcnRWZXJzaW9uLCB7XG4gICAgICAgICAgICBwYWNrYWdlczogY2hhcnRQYWNrYWdlcyxcbiAgICAgICAgICAgIGxhbmd1YWdlOiBjaGFydExhbmd1YWdlLFxuICAgICAgICAgICAgbWFwc0FwaUtleVxuICAgICAgICB9KTtcbiAgICAgICAgZ29vZ2xlLmNoYXJ0cy5zZXRPbkxvYWRDYWxsYmFjaygoKT0+e1xuICAgICAgICAgICAgaWYgKCFpc0dvb2dsZUNoYXJ0c1JlYWR5KHByb3BzLCBnb29nbGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJbR29vZ2xlQ2hhcnRzSW5pdGlhbGl6YXRpb25FcnJvcl0gR29vZ2xlIENoYXJ0cyBub3QgcmVhZHkgYWZ0ZXIgbG9hZCBjYWxsYmFjay5cIik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgc2V0R29vZ2xlQ2hhcnRzSW5pdGlhbGl6YXRpb25FcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0R29vZ2xlQ2hhcnRzKGdvb2dsZSk7XG4gICAgICAgIH0pO1xuICAgIH0sIFtcbiAgICAgICAgaXNTdWNjZXNzXG4gICAgXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IHNjcmlwdExvYWRpbmdFcnJvciB8fCBzY3JpcHRJbml0aWFsaXphdGlvbkVycm9yIHx8IGdvb2dsZUNoYXJ0c0luaXRpYWxpemF0aW9uRXJyb3IsXG4gICAgICAgIGlzTG9hZGluZyxcbiAgICAgICAgZ29vZ2xlOiBnb29nbGVDaGFydHNcbiAgICB9O1xufVxuXG5jb25zdCBjaGFydERlZmF1bHRQcm9wcyA9IHtcbiAgICAvLyA8REVQUkVDQVRFRF9QUk9QUz5cbiAgICBsZWdlbmRfdG9nZ2xlOiBmYWxzZSxcbiAgICAvLyA8L0RFUFJFQ0FURURfUFJPUFM+XG4gICAgb3B0aW9uczoge30sXG4gICAgbGVnZW5kVG9nZ2xlOiBmYWxzZSxcbiAgICBnZXRDaGFydFdyYXBwZXI6ICgpPT57fSxcbiAgICBzcHJlYWRTaGVldFF1ZXJ5UGFyYW1ldGVyczoge1xuICAgICAgICBoZWFkZXJzOiAxLFxuICAgICAgICBnaWQ6IDFcbiAgICB9LFxuICAgIHJvb3RQcm9wczoge30sXG4gICAgY2hhcnRXcmFwcGVyUGFyYW1zOiB7fSxcbiAgICBjaGFydExvYWRlclNjcmlwdFVybDogXCJodHRwczovL3d3dy5nc3RhdGljLmNvbS9jaGFydHMvbG9hZGVyLmpzXCJcbn07XG5cbmNvbnN0IEdvb2dsZUNoYXJ0Q29udHJvbHMgPSAocHJvcHMpPT57XG4gICAgY29uc3QgeyBpc1JlYWR5LCBjaGFydENvbnRyb2xzLCBmaWx0ZXIgfSA9IHByb3BzO1xuICAgIGlmICghaXNSZWFkeSB8fCAhY2hhcnRDb250cm9scyB8fCAhY2hhcnRDb250cm9scz8ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJlYWN0X19kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBjaGFydENvbnRyb2xzLmZpbHRlcigocGFyYW0pPT57XG4gICAgICAgIGxldCB7IGNvbnRyb2xQcm9wLCBjb250cm9sIH0gPSBwYXJhbTtcbiAgICAgICAgcmV0dXJuIGZpbHRlciA/IGZpbHRlcih7XG4gICAgICAgICAgICBjb250cm9sLFxuICAgICAgICAgICAgY29udHJvbFByb3BcbiAgICAgICAgfSkgOiB0cnVlO1xuICAgIH0pLm1hcCgocGFyYW0pPT57XG4gICAgICAgIGxldCB7IGNvbnRyb2wgfSA9IHBhcmFtO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgICAgIGtleTogY29udHJvbC5nZXRDb250YWluZXJJZCgpLFxuICAgICAgICAgICAgaWQ6IGNvbnRyb2wuZ2V0Q29udGFpbmVySWQoKVxuICAgICAgICB9KTtcbiAgICB9KSk7XG59O1xuXG5sZXQgdW5pcXVlSUQgPSAwO1xuY29uc3QgZ2VuZXJhdGVVbmlxdWVJRCA9ICgpPT57XG4gICAgdW5pcXVlSUQgKz0gMTtcbiAgICByZXR1cm4gYHJlYWN0Z29vZ2xlZ3JhcGgtJHt1bmlxdWVJRH1gO1xufTtcblxuLyoqXG4gKiBBbiBpbnRlcm5hbCBoZWxwZXIgY2xhc3MgZm9yIGNyZWF0aW5nIGFuZCBtYW5hZ2luZyBHb29nbGUgQ2hhcnRzIGNvbnRyb2xzLlxuICogT2ZmZXJzIGhpZ2gtbGV2ZWwgbWV0aG9kcyB0byBpbnRlcmFjdCB3aXRoIHRoZSBHb29nbGUgQ2hhcnQgQ29udHJvbHMuXG4gKi8gY2xhc3MgR29vZ2xlQ2hhcnRDb250cm9sc0ludGVybmFsIHtcbiAgICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgY29udHJvbHMgb25jZSBjaGFydCBpcyByZWFkeVxuICAgKi8gc3RhdGljIGluaXRpYWxpemVDb250cm9scyA9IChnb29nbGVDaGFydENvbnRyb2xzKT0+e1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgZ29vZ2xlQ2hhcnRDb250cm9scy5sZW5ndGg7IGkgKz0gMSl7XG4gICAgICAgICAgICBjb25zdCB7IGNvbnRyb2xUeXBlLCBvcHRpb25zLCBjb250cm9sV3JhcHBlclBhcmFtcyB9ID0gZ29vZ2xlQ2hhcnRDb250cm9sc1tpXS5jb250cm9sUHJvcDtcbiAgICAgICAgICAgIGlmIChjb250cm9sV3JhcHBlclBhcmFtcyAmJiBcInN0YXRlXCIgaW4gY29udHJvbFdyYXBwZXJQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBnb29nbGVDaGFydENvbnRyb2xzW2ldLmNvbnRyb2wuc2V0U3RhdGUoY29udHJvbFdyYXBwZXJQYXJhbXNbXCJzdGF0ZVwiXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnb29nbGVDaGFydENvbnRyb2xzW2ldLmNvbnRyb2wuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgIGdvb2dsZUNoYXJ0Q29udHJvbHNbaV0uY29udHJvbC5zZXRDb250cm9sVHlwZShjb250cm9sVHlwZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgKiBsaXN0ZW4gdG8gdGhlIGNvbnRyb2wgZXZlbnRzIChyZWFkeSwgc3RhdGVjaGFuZ2UsIGVycm9yKSBzcGVjaWZpZWQgaW4gdGhlIGNvbnRyb2xFdmVudHMgcHJvcFxuICAgKi8gc3RhdGljIGxpc3RlblRvQ29udHJvbEV2ZW50cyA9IChnb29nbGVDaGFydENvbnRyb2xzLCBwcm9wcyk9PntcbiAgICAgICAgY29uc3QgeyBnb29nbGUgfSA9IHByb3BzO1xuICAgICAgICByZXR1cm4gZ29vZ2xlQ2hhcnRDb250cm9scy5mbGF0TWFwKChjaGFydENvbnRyb2wpPT57XG4gICAgICAgICAgICBjb25zdCB7IGNvbnRyb2wsIGNvbnRyb2xQcm9wIH0gPSBjaGFydENvbnRyb2w7XG4gICAgICAgICAgICBjb25zdCB7IGNvbnRyb2xFdmVudHMgPSBbXSB9ID0gY29udHJvbFByb3A7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbEV2ZW50cy5tYXAoKGV2ZW50KT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY2FsbGJhY2ssIGV2ZW50TmFtZSB9ID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdvb2dsZS52aXN1YWxpemF0aW9uLmV2ZW50cy5hZGRMaXN0ZW5lcihjb250cm9sLCBldmVudE5hbWUsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0V3JhcHBlcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xXcmFwcGVyOiBjb250cm9sLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ29vZ2xlOiBnb29nbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudEFyZ3M6IGFyZ3NcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICogSWYgY29udHJvbElEIGlzIG5vdCBwcm92aWRlZCwgZ2VuZXJhdGUgYSB1bmlxdWUgY29udHJvbElEXG4gICAqLyBzdGF0aWMgY3JlYXRlQ29udHJvbElkID0gKGlkKT0+e1xuICAgICAgICBsZXQgY29udHJvbElEO1xuICAgICAgICBpZiAodHlwZW9mIGlkID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBjb250cm9sSUQgPSBgZ29vZ2xlY2hhcnQtY29udHJvbC0ke2dlbmVyYXRlVW5pcXVlSUQoKX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udHJvbElEID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRyb2xJRDtcbiAgICB9O1xuICAgIC8qKlxuICAgKiBNYXAgdGhlIGNvbnRyb2wgcHJvcHMgdG8gR29vZ2xlIENoYXJ0IENvbnRyb2xzXG4gICAqLyBzdGF0aWMgY3JlYXRlQ2hhcnRDb250cm9scyA9IChwcm9wcyk9PntcbiAgICAgICAgY29uc3QgeyBjb250cm9scywgZ29vZ2xlIH0gPSBwcm9wcztcbiAgICAgICAgaWYgKCFjb250cm9scykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRyb2xzLm1hcCgoY29udHJvbCwgaSk9PntcbiAgICAgICAgICAgIGNvbnN0IHsgY29udHJvbElEOiBjb250cm9sSURNYXliZSwgY29udHJvbFR5cGUsIG9wdGlvbnM6IGNvbnRyb2xPcHRpb25zLCBjb250cm9sV3JhcHBlclBhcmFtcyB9ID0gY29udHJvbDtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xJRCA9IHRoaXMuY3JlYXRlQ29udHJvbElkKGNvbnRyb2xJRE1heWJlKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udHJvbFByb3A6IGNvbnRyb2wsXG4gICAgICAgICAgICAgICAgY29udHJvbDogbmV3IGdvb2dsZS52aXN1YWxpemF0aW9uLkNvbnRyb2xXcmFwcGVyKHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVySWQ6IGNvbnRyb2xJRCxcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbFR5cGUsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IGNvbnRyb2xPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAuLi5jb250cm9sV3JhcHBlclBhcmFtc1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHN0YXRpYyBhZGRDb250cm9scyA9IChwcm9wcyk9PntcbiAgICAgICAgY29uc3QgeyBjaGFydFdyYXBwZXIsIGNoYXJ0RGFzaGJvYXJkIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgZ29vZ2xlQ2hhcnRDb250cm9scyA9IHRoaXMuY3JlYXRlQ2hhcnRDb250cm9scyhwcm9wcyk7XG4gICAgICAgIGlmICghZ29vZ2xlQ2hhcnRDb250cm9scyB8fCAhY2hhcnREYXNoYm9hcmQgfHwgIWNoYXJ0V3JhcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY2hhcnREYXNoYm9hcmQuYmluZChnb29nbGVDaGFydENvbnRyb2xzLm1hcCgocGFyYW0pPT57XG4gICAgICAgICAgICBsZXQgeyBjb250cm9sIH0gPSBwYXJhbTtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sO1xuICAgICAgICB9KSwgY2hhcnRXcmFwcGVyKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplQ29udHJvbHMoZ29vZ2xlQ2hhcnRDb250cm9scyk7XG4gICAgICAgIHJldHVybiBnb29nbGVDaGFydENvbnRyb2xzO1xuICAgIH07XG59XG5cbmNvbnN0IHVzZUNyZWF0ZUNoYXJ0Q29udHJvbHMgPSAoY29udHJvbHMpPT57XG4gICAgY29uc3QgW2NoYXJ0Q29udHJvbHMsIHNldENoYXJ0Q29udHJvbHNdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgY29udHJvbEFuZFByb3AgPSBSZWFjdC51c2VNZW1vKCgpPT57XG4gICAgICAgIGlmICghY2hhcnRDb250cm9scyB8fCAhY29udHJvbHMpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gY29udHJvbHMubWFwKChjb250cm9sUHJvcCwgaSk9PntcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2wgPSBjaGFydENvbnRyb2xzW2ldO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2wgPyB7XG4gICAgICAgICAgICAgICAgY29udHJvbFByb3AsXG4gICAgICAgICAgICAgICAgY29udHJvbFxuICAgICAgICAgICAgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfSkuZmxhdE1hcCgoY29udHJvbEFuZFByb3ApPT5jb250cm9sQW5kUHJvcCA/IFtcbiAgICAgICAgICAgICAgICBjb250cm9sQW5kUHJvcFxuICAgICAgICAgICAgXSA6IFtdKTtcbiAgICB9LCBbXG4gICAgICAgIGNoYXJ0Q29udHJvbHMsXG4gICAgICAgIGNvbnRyb2xzXG4gICAgXSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgY29udHJvbEFuZFByb3AsXG4gICAgICAgIHNldENoYXJ0Q29udHJvbHNcbiAgICBdO1xufTtcbmNvbnN0IHVzZUxpc3RlblRvQ29udHJvbEV2ZW50cyA9IChjaGFydENvbnRyb2xzLCBwcm9wcyk9PntcbiAgICBSZWFjdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gR29vZ2xlQ2hhcnRDb250cm9sc0ludGVybmFsLmxpc3RlblRvQ29udHJvbEV2ZW50cyhjaGFydENvbnRyb2xzID8/IFtdLCBwcm9wcyk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKT0+e1xuICAgICAgICAgICAgICAgIHByb3BzLmdvb2dsZS52aXN1YWxpemF0aW9uLmV2ZW50cy5yZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGNoYXJ0Q29udHJvbHMsXG4gICAgICAgIHByb3BzXG4gICAgXSk7XG59O1xuY29uc3QgdXNlQ2hhcnRDb250cm9scyA9IChwcm9wcyk9PntcbiAgICBjb25zdCBbY2hhcnRDb250cm9scywgc2V0Q2hhcnRDb250cm9sc10gPSB1c2VDcmVhdGVDaGFydENvbnRyb2xzKHByb3BzLmNvbnRyb2xzKTtcbiAgICB1c2VMaXN0ZW5Ub0NvbnRyb2xFdmVudHMoY2hhcnRDb250cm9scyA/PyBbXSwgcHJvcHMpO1xuICAgIC8qKlxuICAgKiBSZW5kZXIgdGhlIGNvbnRhaW5lciBkaXZzIGZvciB0aGUgY29udHJvbHNcbiAgICovIGNvbnN0IHJlbmRlckNvbnRyb2wgPSAoZmlsdGVyKT0+e1xuICAgICAgICBjb25zdCB7IGNoYXJ0V3JhcHBlciwgY2hhcnREYXNoYm9hcmQgfSA9IHByb3BzO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KEdvb2dsZUNoYXJ0Q29udHJvbHMsIHtcbiAgICAgICAgICAgIC4uLnByb3BzLFxuICAgICAgICAgICAgaXNSZWFkeTogQm9vbGVhbihjaGFydFdyYXBwZXIgJiYgY2hhcnREYXNoYm9hcmQpLFxuICAgICAgICAgICAgY2hhcnRDb250cm9sczogY2hhcnRDb250cm9scyxcbiAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkQ29udHJvbHM6IChwcm9wcyk9PntcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xzID0gR29vZ2xlQ2hhcnRDb250cm9sc0ludGVybmFsLmFkZENvbnRyb2xzKHByb3BzKTtcbiAgICAgICAgICAgIHNldENoYXJ0Q29udHJvbHMoY29udHJvbHM/Lm1hcCgoY29udHJvbCk9PmNvbnRyb2wuY29udHJvbCkgPz8gbnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbmRlckNvbnRyb2xcbiAgICB9O1xufTtcblxuY29uc3QgdXNlQ2hhcnRJZCA9IChwcm9wcyk9PntcbiAgICBjb25zdCBjaGFydElkUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGdldENoYXJ0SWQgPSAoKT0+e1xuICAgICAgICBjb25zdCB7IGdyYXBoSUQsIGdyYXBoX2lkIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgY2hhcnRJZEZyb21Qcm9wcyA9IGdyYXBoSUQgfHwgZ3JhcGhfaWQ7XG4gICAgICAgIGxldCBjdXJyZW50Q2hhcnRJZDtcbiAgICAgICAgaWYgKGNoYXJ0SWRGcm9tUHJvcHMpIHtcbiAgICAgICAgICAgIGN1cnJlbnRDaGFydElkID0gY2hhcnRJZEZyb21Qcm9wcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnRDaGFydElkID0gY2hhcnRJZFJlZi5jdXJyZW50IHx8IGdlbmVyYXRlVW5pcXVlSUQoKTtcbiAgICAgICAgfVxuICAgICAgICBjaGFydElkUmVmLmN1cnJlbnQgPSBjdXJyZW50Q2hhcnRJZDtcbiAgICAgICAgcmV0dXJuIGNoYXJ0SWRSZWYuY3VycmVudDtcbiAgICB9O1xuICAgIGNvbnN0IGNoYXJ0SWQgPSBnZXRDaGFydElkKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hhcnRJZFxuICAgIH07XG59O1xuXG5jb25zdCBERUZBVUxUX0NIQVJUX0NPTE9SUyA9IFtcbiAgICBcIiMzMzY2Q0NcIixcbiAgICBcIiNEQzM5MTJcIixcbiAgICBcIiNGRjk5MDBcIixcbiAgICBcIiMxMDk2MThcIixcbiAgICBcIiM5OTAwOTlcIixcbiAgICBcIiMzQjNFQUNcIixcbiAgICBcIiMwMDk5QzZcIixcbiAgICBcIiNERDQ0NzdcIixcbiAgICBcIiM2NkFBMDBcIixcbiAgICBcIiNCODJFMkVcIixcbiAgICBcIiMzMTYzOTVcIixcbiAgICBcIiM5OTQ0OTlcIixcbiAgICBcIiMyMkFBOTlcIixcbiAgICBcIiNBQUFBMTFcIixcbiAgICBcIiM2NjMzQ0NcIixcbiAgICBcIiNFNjczMDBcIixcbiAgICBcIiM4QjA3MDdcIixcbiAgICBcIiMzMjkyNjJcIixcbiAgICBcIiM1NTc0QTZcIixcbiAgICBcIiMzQjNFQUNcIlxuXTtcblxuY29uc3QgbG9hZERhdGFUYWJsZUZyb21TcHJlYWRTaGVldCA9IGFzeW5jIGZ1bmN0aW9uKGdvb2dsZVZpeiwgc3ByZWFkU2hlZXRVcmwpIHtcbiAgICBsZXQgdXJsUGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IGAke3VybFBhcmFtcy5oZWFkZXJzID8gYGhlYWRlcnM9JHt1cmxQYXJhbXMuaGVhZGVyc31gIDogYGhlYWRlcnM9MGB9YDtcbiAgICAgICAgY29uc3QgcXVlcnlTdHJpbmcgPSBgJHt1cmxQYXJhbXMucXVlcnkgPyBgJnRxPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHVybFBhcmFtcy5xdWVyeSl9YCA6IGBgfWA7XG4gICAgICAgIGNvbnN0IGdpZCA9IGAke3VybFBhcmFtcy5naWQgPyBgJmdpZD0ke3VybFBhcmFtcy5naWR9YCA6IFwiXCJ9YDtcbiAgICAgICAgY29uc3Qgc2hlZXQgPSBgJHt1cmxQYXJhbXMuc2hlZXQgPyBgJnNoZWV0PSR7dXJsUGFyYW1zLnNoZWV0fWAgOiBcIlwifWA7XG4gICAgICAgIGNvbnN0IGFjY2Vzc190b2tlbiA9IGAke3VybFBhcmFtcy5hY2Nlc3NfdG9rZW4gPyBgJmFjY2Vzc190b2tlbj0ke3VybFBhcmFtcy5hY2Nlc3NfdG9rZW59YCA6IFwiXCJ9YDtcbiAgICAgICAgY29uc3QgdXJsUXVlcnlTdHJpbmcgPSBgJHtoZWFkZXJzfSR7Z2lkfSR7c2hlZXR9JHtxdWVyeVN0cmluZ30ke2FjY2Vzc190b2tlbn1gO1xuICAgICAgICBjb25zdCB1cmxUb1NwcmVhZFNoZWV0ID0gYCR7c3ByZWFkU2hlZXRVcmx9L2d2aXovdHE/JHt1cmxRdWVyeVN0cmluZ31gOyAvLyZ0cT0ke3F1ZXJ5U3RyaW5nfWA7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IGdvb2dsZVZpei52aXN1YWxpemF0aW9uLlF1ZXJ5KHVybFRvU3ByZWFkU2hlZXQpO1xuICAgICAgICBxdWVyeS5zZW5kKChyZXNwb25zZSk9PntcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5pc0Vycm9yKCkpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoYEVycm9yIGluIHF1ZXJ5OiAgJHtyZXNwb25zZS5nZXRNZXNzYWdlKCl9ICR7cmVzcG9uc2UuZ2V0RGV0YWlsZWRNZXNzYWdlKCl9YCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UuZ2V0RGF0YVRhYmxlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbmNvbnN0IEdSQVlfQ09MT1IgPSBcIiNDQ0NDQ0NcIjtcbi8qKlxuICogQW4gaW50ZXJuYWwgaGVscGVyIGNsYXNzIGFyb3VuZCB0aGUgR29vZ2xlIENoYXJ0IEFQSS5cbiAqIE9mZmVycyBoaWdoLWxldmVsIG1ldGhvZHMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgR29vZ2xlIENoYXJ0IEFQSS5cbiAqLyBjbGFzcyBHb29nbGVDaGFydEludGVybmFsIHtcbiAgICBzdGF0aWMgZ3JheU91dEhpZGRlbkNvbHVtbnNMYWJlbCA9IChwcm9wcywgaGlkZGVuQ29sdW1ucyk9PntcbiAgICAgICAgY29uc3QgeyBnb29nbGVDaGFydFdyYXBwZXIsIG9wdGlvbnMgfSA9IHByb3BzO1xuICAgICAgICBpZiAoIWdvb2dsZUNoYXJ0V3JhcHBlcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImdvb2dsZUNoYXJ0V3JhcHBlciBpcyBub3QgZGVmaW5lZFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhVGFibGUgPSBnb29nbGVDaGFydFdyYXBwZXIuZ2V0RGF0YVRhYmxlKCk7XG4gICAgICAgIGlmICghZGF0YVRhYmxlKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGNvbHVtbkNvdW50ID0gZGF0YVRhYmxlLmdldE51bWJlck9mQ29sdW1ucygpO1xuICAgICAgICBjb25zdCBoYXNBSGlkZGVuQ29sdW1uID0gaGlkZGVuQ29sdW1ucy5sZW5ndGggPiAwO1xuICAgICAgICBpZiAoaGFzQUhpZGRlbkNvbHVtbiA9PT0gZmFsc2UpIHJldHVybjtcbiAgICAgICAgY29uc3QgY29sb3JzID0gQXJyYXkuZnJvbSh7XG4gICAgICAgICAgICBsZW5ndGg6IGNvbHVtbkNvdW50IC0gMVxuICAgICAgICB9KS5tYXAoKF9kb250Y2FyZSwgaSk9PntcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbklEID0gdGhpcy5nZXRDb2x1bW5JZChkYXRhVGFibGUsIGkgKyAxKTtcbiAgICAgICAgICAgIGlmIChoaWRkZW5Db2x1bW5zLmluY2x1ZGVzKGNvbHVtbklEKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBHUkFZX0NPTE9SO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY29sb3JzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY29sb3JzW2ldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gREVGQVVMVF9DSEFSVF9DT0xPUlNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBnb29nbGVDaGFydFdyYXBwZXIuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgY29sb3JzXG4gICAgICAgIH0pO1xuICAgICAgICBnb29nbGVDaGFydFdyYXBwZXIuZHJhdygpO1xuICAgIH07XG4gICAgLyoqXG4gICAqIExpc3RlbnMgdG8gdXNlciBjbGlja2luZyBvbiB0aGUgbGVnZW5kIHRvIHRvZ2dsZSB0aGUgdmlzaWJpbGl0eSBvZiBhIGNvbHVtbi5cbiAgICogV2hlbiBhIHVzZXIgY2xpY2tzIG9uIGEgbGVnZW5kIGl0ZW0sIHRoZSBjb2x1bW4gaWQgaXMgYWRkZWQgdG8gLyByZW1vdmVkIGZyb20gdGhlIGhpZGRlbkNvbHVtbnMgc3RhdGUuXG4gICAqLyBzdGF0aWMgbGlzdGVuVG9MZWdlbmRUb2dnbGUgPSAocHJvcHMsIGhpZGRlbkNvbHVtbnNTdGF0ZSk9PntcbiAgICAgICAgY29uc3QgW2hpZGRlbkNvbHVtbnMsIHNldEhpZGRlbkNvbHVtbnNdID0gaGlkZGVuQ29sdW1uc1N0YXRlO1xuICAgICAgICBjb25zdCB7IGdvb2dsZSwgZ29vZ2xlQ2hhcnRXcmFwcGVyIH0gPSBwcm9wcztcbiAgICAgICAgaWYgKCFnb29nbGVDaGFydFdyYXBwZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJnb29nbGVDaGFydFdyYXBwZXIgaXMgbm90IGRlZmluZWRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdvb2dsZS52aXN1YWxpemF0aW9uLmV2ZW50cy5hZGRMaXN0ZW5lcihnb29nbGVDaGFydFdyYXBwZXIsIFwic2VsZWN0XCIsICgpPT57XG4gICAgICAgICAgICBjb25zdCBjaGFydCA9IGdvb2dsZUNoYXJ0V3JhcHBlci5nZXRDaGFydCgpO1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gY2hhcnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBkYXRhVGFibGUgPSBnb29nbGVDaGFydFdyYXBwZXIuZ2V0RGF0YVRhYmxlKCk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLmxlbmd0aCA9PT0gMCB8fCAvLyBXZSB3YW50IHRvIGxpc3RlbiB0byB3aGVuIGEgd2hvbGUgcm93IGlzIHNlbGVjdGVkLiBUaGlzIGlzIHRoZSBjYXNlIG9ubHkgd2hlbiByb3cgPT09IG51bGxcbiAgICAgICAgICAgIHNlbGVjdGlvblswXS5yb3cgIT09IG51bGwgfHwgIWRhdGFUYWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbkluZGV4ID0gc2VsZWN0aW9uWzBdLmNvbHVtbjtcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbklEID0gdGhpcy5nZXRDb2x1bW5JZChkYXRhVGFibGUsIGNvbHVtbkluZGV4KTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBjb2x1bW4gaXMgaGlkZGVuIHJlbW92ZSBpdCBmcm9tIHN0YXRlLCBvdGhlcndpc2UgYWRkIGl0XG4gICAgICAgICAgICBpZiAoaGlkZGVuQ29sdW1ucz8uaW5jbHVkZXMoY29sdW1uSUQpKSB7XG4gICAgICAgICAgICAgICAgc2V0SGlkZGVuQ29sdW1ucygoc3RhdGUpPT5bXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5zdGF0ZS5maWx0ZXIoKGNvbElEKT0+Y29sSUQgIT09IGNvbHVtbklEKVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0SGlkZGVuQ29sdW1ucygoc3RhdGUpPT5bXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbklEXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgKiAoUmUtKURyYXcgYSBHb29nbGUgQ2hhcnQgd2l0aCB0aGUgZ2l2ZW4gZGF0YSwgb3B0aW9ucywgYW5kIGNoYXJ0IHR5cGUuXG4gICAqLyBzdGF0aWMgZHJhdyA9IGFzeW5jIChwcm9wcyk9PntcbiAgICAgICAgY29uc3QgeyBkYXRhLCBkaWZmZGF0YSwgcm93cywgY29sdW1ucywgb3B0aW9ucywgY2hhcnRUeXBlLCBmb3JtYXR0ZXJzLCBzcHJlYWRTaGVldFVybCwgc3ByZWFkU2hlZXRRdWVyeVBhcmFtZXRlcnMsIGdvb2dsZUNoYXJ0RGFzaGJvYXJkLCBnb29nbGVDaGFydFdyYXBwZXIsIGdvb2dsZSwgaGlkZGVuQ29sdW1ucywgbGVnZW5kVG9nZ2xlLCBsZWdlbmRfdG9nZ2xlIH0gPSBwcm9wcztcbiAgICAgICAgaWYgKCFnb29nbGVDaGFydFdyYXBwZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJkcmF3IHdhcyBjYWxsZWQgd2l0aCBnb29nbGVDaGFydFdyYXBwZXIgPSBudWxsXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhVGFibGU7XG4gICAgICAgIGxldCBjaGFydERpZmYgPSBudWxsO1xuICAgICAgICBpZiAoZGlmZmRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IG9sZERhdGEgPSBnb29nbGUudmlzdWFsaXphdGlvbi5hcnJheVRvRGF0YVRhYmxlKGRpZmZkYXRhLm9sZCk7XG4gICAgICAgICAgICBjb25zdCBuZXdEYXRhID0gZ29vZ2xlLnZpc3VhbGl6YXRpb24uYXJyYXlUb0RhdGFUYWJsZShkaWZmZGF0YS5uZXcpO1xuICAgICAgICAgICAgY2hhcnREaWZmID0gZ29vZ2xlLnZpc3VhbGl6YXRpb25bY2hhcnRUeXBlXS5wcm90b3R5cGUuY29tcHV0ZURpZmYob2xkRGF0YSwgbmV3RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgZGF0YVRhYmxlID0gZ29vZ2xlLnZpc3VhbGl6YXRpb24uYXJyYXlUb0RhdGFUYWJsZShkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YVRhYmxlID0gbmV3IGdvb2dsZS52aXN1YWxpemF0aW9uLkRhdGFUYWJsZShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChyb3dzICYmIGNvbHVtbnMpIHtcbiAgICAgICAgICAgIGRhdGFUYWJsZSA9IGdvb2dsZS52aXN1YWxpemF0aW9uLmFycmF5VG9EYXRhVGFibGUoW1xuICAgICAgICAgICAgICAgIGNvbHVtbnMsXG4gICAgICAgICAgICAgICAgLi4ucm93c1xuICAgICAgICAgICAgXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3ByZWFkU2hlZXRVcmwpIHtcbiAgICAgICAgICAgIGRhdGFUYWJsZSA9IGF3YWl0IGxvYWREYXRhVGFibGVGcm9tU3ByZWFkU2hlZXQoZ29vZ2xlLCBzcHJlYWRTaGVldFVybCwgc3ByZWFkU2hlZXRRdWVyeVBhcmFtZXRlcnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YVRhYmxlID0gZ29vZ2xlLnZpc3VhbGl6YXRpb24uYXJyYXlUb0RhdGFUYWJsZShbXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29sdW1uQ291bnQgPSBkYXRhVGFibGUuZ2V0TnVtYmVyT2ZDb2x1bW5zKCk7XG4gICAgICAgIGNvbnN0IHZpZXdDb2x1bW5zID0gQXJyYXkoY29sdW1uQ291bnQpLmZpbGwoMCkubWFwKChfYywgaSk9PntcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbklEID0gdGhpcy5nZXRDb2x1bW5JZChkYXRhVGFibGUsIGkpO1xuICAgICAgICAgICAgaWYgKGhpZGRlbkNvbHVtbnMuaW5jbHVkZXMoY29sdW1uSUQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGRhdGFUYWJsZS5nZXRDb2x1bW5MYWJlbChpKSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZGF0YVRhYmxlLmdldENvbHVtblR5cGUoaSksXG4gICAgICAgICAgICAgICAgICAgIGNhbGM6ICgpPT5udWxsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjaGFydCA9IGdvb2dsZUNoYXJ0V3JhcHBlci5nZXRDaGFydCgpO1xuICAgICAgICBpZiAoZ29vZ2xlQ2hhcnRXcmFwcGVyLmdldENoYXJ0VHlwZSgpID09PSBcIlRpbWVsaW5lXCIpIHtcbiAgICAgICAgICAgIGNoYXJ0ICYmIGNoYXJ0LmNsZWFyQ2hhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBnb29nbGVDaGFydFdyYXBwZXIuc2V0Q2hhcnRUeXBlKGNoYXJ0VHlwZSk7XG4gICAgICAgIGdvb2dsZUNoYXJ0V3JhcHBlci5zZXRPcHRpb25zKG9wdGlvbnMgfHwge30pO1xuICAgICAgICBjb25zdCB2aWV3VGFibGUgPSBuZXcgZ29vZ2xlLnZpc3VhbGl6YXRpb24uRGF0YVZpZXcoZGF0YVRhYmxlKTtcbiAgICAgICAgdmlld1RhYmxlLnNldENvbHVtbnModmlld0NvbHVtbnMpO1xuICAgICAgICBnb29nbGVDaGFydFdyYXBwZXIuc2V0RGF0YVRhYmxlKHZpZXdUYWJsZSk7XG4gICAgICAgIGdvb2dsZUNoYXJ0V3JhcHBlci5kcmF3KCk7XG4gICAgICAgIGlmIChnb29nbGVDaGFydERhc2hib2FyZCkge1xuICAgICAgICAgICAgZ29vZ2xlQ2hhcnREYXNoYm9hcmQuZHJhdyhkYXRhVGFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFydERpZmYpIHtcbiAgICAgICAgICAgIGdvb2dsZUNoYXJ0V3JhcHBlci5zZXREYXRhVGFibGUoY2hhcnREaWZmKTtcbiAgICAgICAgICAgIGdvb2dsZUNoYXJ0V3JhcHBlci5kcmF3KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdHRlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlGb3JtYXR0ZXJzKHtcbiAgICAgICAgICAgICAgICBkYXRhVGFibGUsXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVycyxcbiAgICAgICAgICAgICAgICBnb29nbGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ29vZ2xlQ2hhcnRXcmFwcGVyLnNldERhdGFUYWJsZShkYXRhVGFibGUpO1xuICAgICAgICAgICAgZ29vZ2xlQ2hhcnRXcmFwcGVyLmRyYXcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVnZW5kVG9nZ2xlID09PSB0cnVlIHx8IGxlZ2VuZF90b2dnbGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JheU91dEhpZGRlbkNvbHVtbnNMYWJlbChwcm9wcywgaGlkZGVuQ29sdW1ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgLyoqXG4gICAqIEdldCB0aGUgY29sdW1uIElEIG9mIGEgY29sdW1uIGluIGEgR29vZ2xlRGF0YVRhYmxlLlxuICAgKiBJZiB0aGUgY29sdW1uIGhhcyBhbiBJRCwgcmV0dXJuIHRoZSBJRCwgb3RoZXJ3aXNlIHJldHVybiB0aGUgbGFiZWwuXG4gICAqLyBzdGF0aWMgZ2V0Q29sdW1uSWQgPSAoZGF0YVRhYmxlLCBjb2x1bW5JbmRleCk9PntcbiAgICAgICAgcmV0dXJuIGRhdGFUYWJsZS5nZXRDb2x1bW5JZChjb2x1bW5JbmRleCkgfHwgZGF0YVRhYmxlLmdldENvbHVtbkxhYmVsKGNvbHVtbkluZGV4KTtcbiAgICB9O1xuICAgIC8qKlxuICAgKiBBcHBseSBDaGFydCBGb3JtYXR0ZXJzIHBhc3NlZCB1bmRlciB0aGUgZm9ybWF0dGVycyBwcm9wIHRvIHRoZSBHb29nbGVEYXRhVGFibGVcbiAgICovIHN0YXRpYyBhcHBseUZvcm1hdHRlcnMgPSAocGFyYW0pPT57XG4gICAgICAgIGxldCB7IGRhdGFUYWJsZSwgZm9ybWF0dGVycywgZ29vZ2xlIH0gPSBwYXJhbTtcbiAgICAgICAgZm9yIChsZXQgZm9ybWF0dGVyIG9mIGZvcm1hdHRlcnMpe1xuICAgICAgICAgICAgc3dpdGNoKGZvcm1hdHRlci50eXBlKXtcbiAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dGb3JtYXRcIjpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgdml6Rm9ybWF0dGVyID0gbmV3IGdvb2dsZS52aXN1YWxpemF0aW9uLkFycm93Rm9ybWF0KGZvcm1hdHRlci5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpekZvcm1hdHRlci5mb3JtYXQoZGF0YVRhYmxlLCBmb3JtYXR0ZXIuY29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJCYXJGb3JtYXRcIjpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgdml6Rm9ybWF0dGVyID0gbmV3IGdvb2dsZS52aXN1YWxpemF0aW9uLkJhckZvcm1hdChmb3JtYXR0ZXIub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXpGb3JtYXR0ZXIuZm9ybWF0KGRhdGFUYWJsZSwgZm9ybWF0dGVyLmNvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiQ29sb3JGb3JtYXRcIjpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgdml6Rm9ybWF0dGVyID0gbmV3IGdvb2dsZS52aXN1YWxpemF0aW9uLkNvbG9yRm9ybWF0KGZvcm1hdHRlci5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcmFuZ2VzIH0gPSBmb3JtYXR0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcmFuZ2Ugb2YgcmFuZ2VzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdml6Rm9ybWF0dGVyLmFkZFJhbmdlKC4uLnJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXpGb3JtYXR0ZXIuZm9ybWF0KGRhdGFUYWJsZSwgZm9ybWF0dGVyLmNvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiRGF0ZUZvcm1hdFwiOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2aXpGb3JtYXR0ZXIgPSBuZXcgZ29vZ2xlLnZpc3VhbGl6YXRpb24uRGF0ZUZvcm1hdChmb3JtYXR0ZXIub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXpGb3JtYXR0ZXIuZm9ybWF0KGRhdGFUYWJsZSwgZm9ybWF0dGVyLmNvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiTnVtYmVyRm9ybWF0XCI6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpekZvcm1hdHRlciA9IG5ldyBnb29nbGUudmlzdWFsaXphdGlvbi5OdW1iZXJGb3JtYXQoZm9ybWF0dGVyLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdml6Rm9ybWF0dGVyLmZvcm1hdChkYXRhVGFibGUsIGZvcm1hdHRlci5jb2x1bW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcIlBhdHRlcm5Gb3JtYXRcIjpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgdml6Rm9ybWF0dGVyID0gbmV3IGdvb2dsZS52aXN1YWxpemF0aW9uLlBhdHRlcm5Gb3JtYXQoZm9ybWF0dGVyLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdml6Rm9ybWF0dGVyLmZvcm1hdChkYXRhVGFibGUsIGZvcm1hdHRlci5jb2x1bW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbmtub3duIGZvcm1hdHRlciB0eXBlOiAke2Zvcm1hdHRlci50eXBlfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5jb25zdCB1c2VHb29nbGVDaGFydERhdGFUYWJsZSA9IChwcm9wcyk9PntcbiAgICBjb25zdCB7IGdvb2dsZSwgZ29vZ2xlQ2hhcnRXcmFwcGVyLCBnb29nbGVDaGFydERhc2hib2FyZCB9ID0gcHJvcHM7XG4gICAgY29uc3QgW2hpZGRlbkNvbHVtbnMsIHNldEhpZGRlbkNvbHVtbnNdID0gUmVhY3QudXNlU3RhdGUoW10pO1xuICAgIC8vIFJlLWRyYXcgdGhlIGNoYXJ0IHdoZW4gaGlkZGVuQ29sdW1ucyBjaGFuZ2VcbiAgICBSZWFjdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKCFnb29nbGVDaGFydFdyYXBwZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBHb29nbGVDaGFydEludGVybmFsLmRyYXcoe1xuICAgICAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgICAgICBoaWRkZW5Db2x1bW5zLFxuICAgICAgICAgICAgZ29vZ2xlQ2hhcnRXcmFwcGVyLFxuICAgICAgICAgICAgZ29vZ2xlQ2hhcnREYXNoYm9hcmQsXG4gICAgICAgICAgICBnb29nbGVcbiAgICAgICAgfSk7XG4gICAgfSwgW1xuICAgICAgICBoaWRkZW5Db2x1bW5zLFxuICAgICAgICBwcm9wcy5kYXRhLFxuICAgICAgICBwcm9wcy5yb3dzLFxuICAgICAgICBwcm9wcy5jb2x1bW5zLFxuICAgICAgICBwcm9wcy5vcHRpb25zLFxuICAgICAgICBwcm9wcy5jaGFydExvYWRlclNjcmlwdFVybCxcbiAgICAgICAgcHJvcHMuY2hhcnRUeXBlLFxuICAgICAgICBwcm9wcy5mb3JtYXR0ZXJzLFxuICAgICAgICBwcm9wcy5zcHJlYWRTaGVldFVybCxcbiAgICAgICAgcHJvcHMuc3ByZWFkU2hlZXRRdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgIHByb3BzLmxlZ2VuZFRvZ2dsZSxcbiAgICAgICAgcHJvcHMubGVnZW5kX3RvZ2dsZVxuICAgIF0pO1xuICAgIC8vIFJlLWRyYXcgdGhlIGNoYXJ0IHdoZW4gdGhlIHdpbmRvdyBpcyByZXNpemVkXG4gICAgY29uc3Qgb25SZXNpemUgPSAoKT0+e1xuICAgICAgICBjb25zdCB7IGdvb2dsZUNoYXJ0V3JhcHBlciB9ID0gcHJvcHM7XG4gICAgICAgIGlmICghZ29vZ2xlQ2hhcnRXcmFwcGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZ29vZ2xlQ2hhcnRXcmFwcGVyLmRyYXcoKTtcbiAgICB9O1xuICAgIC8vIERyYXcgdGhlIGNoYXJ0IHdoZW4gdGhlIGdvb2dsZSBjaGFydHMgd3JhcHBlciBpcyByZWFkeSBhbmQgd2hlbiB0aGUgaGlkZGVuQ29sdW1ucyBjaGFuZ2VcbiAgICBjb25zdCBpbml0aWFsaXplID0gKGdvb2dsZUNoYXJ0V3JhcHBlcik9PntcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gW107XG4gICAgICAgIGNvbnN0IHsgbGVnZW5kVG9nZ2xlLCBsZWdlbmRfdG9nZ2xlIH0gPSBwcm9wcztcbiAgICAgICAgR29vZ2xlQ2hhcnRJbnRlcm5hbC5kcmF3KHtcbiAgICAgICAgICAgIC4uLnByb3BzLFxuICAgICAgICAgICAgaGlkZGVuQ29sdW1ucyxcbiAgICAgICAgICAgIGdvb2dsZUNoYXJ0V3JhcHBlcixcbiAgICAgICAgICAgIGdvb2dsZUNoYXJ0RGFzaGJvYXJkLFxuICAgICAgICAgICAgZ29vZ2xlXG4gICAgICAgIH0pO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBvblJlc2l6ZSk7XG4gICAgICAgIGlmIChsZWdlbmRfdG9nZ2xlIHx8IGxlZ2VuZFRvZ2dsZSkge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBHb29nbGVDaGFydEludGVybmFsLmxpc3RlblRvTGVnZW5kVG9nZ2xlKHByb3BzLCBbXG4gICAgICAgICAgICAgICAgaGlkZGVuQ29sdW1ucyxcbiAgICAgICAgICAgICAgICBzZXRIaWRkZW5Db2x1bW5zXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcikgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcnM7XG4gICAgfTtcbiAgICAvLyBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzIGFuZCBjbGVhciB0aGUgY2hhcnQgd2hlbiB0aGUgY29tcG9uZW50IGlzIHVubW91bnRlZFxuICAgIGNvbnN0IGRlc3Ryb3kgPSAoZ29vZ2xlQ2hhcnRXcmFwcGVyLCBsaXN0ZW5lcnMpPT57XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIG9uUmVzaXplKTtcbiAgICAgICAgbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKT0+e1xuICAgICAgICAgICAgZ29vZ2xlLnZpc3VhbGl6YXRpb24uZXZlbnRzLnJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChnb29nbGVDaGFydFdyYXBwZXIuZ2V0Q2hhcnRUeXBlKCkgPT09IFwiVGltZWxpbmVcIikge1xuICAgICAgICAgICAgZ29vZ2xlQ2hhcnRXcmFwcGVyLmdldENoYXJ0KCkgJiYgZ29vZ2xlQ2hhcnRXcmFwcGVyLmdldENoYXJ0KCkuY2xlYXJDaGFydCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKCFnb29nbGVDaGFydFdyYXBwZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBpbml0aWFsaXplKGdvb2dsZUNoYXJ0V3JhcHBlcik7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgZGVzdHJveShnb29nbGVDaGFydFdyYXBwZXIsIGxpc3RlbmVycyk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBnb29nbGVDaGFydFdyYXBwZXIsXG4gICAgICAgIGluaXRpYWxpemUsXG4gICAgICAgIGRlc3Ryb3lcbiAgICBdKTtcbn07XG5cbmNvbnN0IGxpc3RlblRvRXZlbnRzID0gKHByb3BzKT0+e1xuICAgIGNvbnN0IHsgY2hhcnRFdmVudHMsIGdvb2dsZSwgZ29vZ2xlQ2hhcnRXcmFwcGVyIH0gPSBwcm9wcztcbiAgICBpZiAoIWNoYXJ0RXZlbnRzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFnb29nbGVDaGFydFdyYXBwZXIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwibGlzdGVuVG9FdmVudHMgd2FzIGNhbGxlZCBiZWZvcmUgY2hhcnQgd3JhcHBlciByZWFkeS5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJ0RXZlbnRzLm1hcCgocGFyYW0pPT57XG4gICAgICAgIGxldCB7IGV2ZW50TmFtZSwgY2FsbGJhY2sgfSA9IHBhcmFtO1xuICAgICAgICByZXR1cm4gZ29vZ2xlLnZpc3VhbGl6YXRpb24uZXZlbnRzLmFkZExpc3RlbmVyKGdvb2dsZUNoYXJ0V3JhcHBlciwgZXZlbnROYW1lLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgIGNoYXJ0V3JhcHBlcjogZ29vZ2xlQ2hhcnRXcmFwcGVyLFxuICAgICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICAgIGdvb2dsZTogZ29vZ2xlLFxuICAgICAgICAgICAgICAgIGV2ZW50QXJnczogYXJnc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmNvbnN0IHVzZUdvb2dsZUNoYXJ0RXZlbnRzID0gKHByb3BzKT0+e1xuICAgIHVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAoIXByb3BzLmdvb2dsZUNoYXJ0V3JhcHBlcikgcmV0dXJuO1xuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBsaXN0ZW5Ub0V2ZW50cyhwcm9wcyk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgbGlzdGVuZXJzPy5mb3JFYWNoKChsaXN0ZW5lcik9PntcbiAgICAgICAgICAgICAgICBwcm9wcy5nb29nbGUudmlzdWFsaXphdGlvbi5ldmVudHMucmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBwcm9wc1xuICAgIF0pO1xufTtcblxuY29uc3QgR29vZ2xlQ2hhcnQgPSAocHJvcHMpPT57XG4gICAgY29uc3QgW2dvb2dsZUNoYXJ0V3JhcHBlciwgc2V0R29vZ2xlQ2hhcnRXcmFwcGVyXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICAgIC8vIGNvbnN0IFtpc1JlYWR5LCBzZXRJc1JlYWR5XSA9IFJlYWN0LnVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcbiAgICBjb25zdCBbZ29vZ2xlQ2hhcnREYXNoYm9hcmQsIHNldEdvb2dsZUNoYXJ0RGFzaGJvYXJkXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IHsgYWRkQ29udHJvbHMsIHJlbmRlckNvbnRyb2wgfSA9IHVzZUNoYXJ0Q29udHJvbHMoe1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgY2hhcnREYXNoYm9hcmQ6IGdvb2dsZUNoYXJ0RGFzaGJvYXJkLFxuICAgICAgICBjaGFydFdyYXBwZXI6IGdvb2dsZUNoYXJ0V3JhcHBlclxuICAgIH0pO1xuICAgIHVzZUdvb2dsZUNoYXJ0RXZlbnRzKHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIGdvb2dsZUNoYXJ0V3JhcHBlclxuICAgIH0pO1xuICAgIGNvbnN0IHsgY2hhcnRJZCB9ID0gdXNlQ2hhcnRJZChwcm9wcyk7XG4gICAgY29uc3QgZGFzaGJvYXJkUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHRvb2xiYXJSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucywgZ29vZ2xlLCBjaGFydFR5cGUsIGNoYXJ0V3JhcHBlclBhcmFtcywgdG9vbGJhckl0ZW1zLCBnZXRDaGFydEVkaXRvciwgZ2V0Q2hhcnRXcmFwcGVyLCBvbkxvYWQgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBjaGFydENvbmZpZyA9IHtcbiAgICAgICAgICAgIGNoYXJ0VHlwZSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBjb250YWluZXJJZDogY2hhcnRJZCxcbiAgICAgICAgICAgIC4uLmNoYXJ0V3JhcHBlclBhcmFtc1xuICAgICAgICB9O1xuICAgICAgICAvLyBDcmVhdGUgQ2hhcnRXcmFwcGVyIGluc3RhbmNlLCBwYXNzIGl0IHRvIHRoZSB1c2VyIGFuZCBzdG9yZSBpdCBpbiBzdGF0ZVxuICAgICAgICBjb25zdCBjaGFydFdyYXBwZXIgPSBuZXcgZ29vZ2xlLnZpc3VhbGl6YXRpb24uQ2hhcnRXcmFwcGVyKGNoYXJ0Q29uZmlnKTtcbiAgICAgICAgY2hhcnRXcmFwcGVyLnNldE9wdGlvbnMob3B0aW9ucyB8fCB7fSk7XG4gICAgICAgIGdldENoYXJ0V3JhcHBlcj8uKGNoYXJ0V3JhcHBlciwgZ29vZ2xlKTtcbiAgICAgICAgLy8gQ3JlYXRlIERhc2hib2FyZCBpbnN0YW5jZSwgbmVlZGVkIGZvciBjb250cm9sc1xuICAgICAgICBjb25zdCBjaGFydERhc2hib2FyZCA9IG5ldyBnb29nbGUudmlzdWFsaXphdGlvbi5EYXNoYm9hcmQoZGFzaGJvYXJkUmVmLmN1cnJlbnQpO1xuICAgICAgICAvLyBDcmVhdGUgdG9vbGJhciBpZiBuZWVkZWRcbiAgICAgICAgaWYgKHRvb2xiYXJJdGVtcykge1xuICAgICAgICAgICAgZ29vZ2xlLnZpc3VhbGl6YXRpb24uZHJhd1Rvb2xiYXIodG9vbGJhclJlZi5jdXJyZW50LCB0b29sYmFySXRlbXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBDaGFydEVkaXRvciBpbnN0YW5jZSBpZiBuZWVkZWQgYW5kIHBhc3MgaXQgdG8gdGhlIHVzZXJcbiAgICAgICAgbGV0IGNoYXJ0RWRpdG9yID0gbnVsbDtcbiAgICAgICAgaWYgKGdldENoYXJ0RWRpdG9yKSB7XG4gICAgICAgICAgICBjaGFydEVkaXRvciA9IG5ldyBnb29nbGUudmlzdWFsaXphdGlvbi5DaGFydEVkaXRvcigpO1xuICAgICAgICAgICAgZ2V0Q2hhcnRFZGl0b3Ioe1xuICAgICAgICAgICAgICAgIGNoYXJ0RWRpdG9yLFxuICAgICAgICAgICAgICAgIGNoYXJ0V3JhcHBlcixcbiAgICAgICAgICAgICAgICBnb29nbGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhbmQgYWRkIGNvbnRyb2xzIHRvIHRoZSBjaGFydCAvIGRhc2hib2FyZFxuICAgICAgICBhZGRDb250cm9scyh7XG4gICAgICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgICAgIGNoYXJ0RGFzaGJvYXJkLFxuICAgICAgICAgICAgY2hhcnRXcmFwcGVyXG4gICAgICAgIH0pO1xuICAgICAgICBzZXRHb29nbGVDaGFydFdyYXBwZXIoY2hhcnRXcmFwcGVyKTtcbiAgICAgICAgc2V0R29vZ2xlQ2hhcnREYXNoYm9hcmQoY2hhcnREYXNoYm9hcmQpO1xuICAgICAgICBvbkxvYWQ/Lihnb29nbGUsIHtcbiAgICAgICAgICAgIGdvb2dsZSxcbiAgICAgICAgICAgIGNoYXJ0V3JhcHBlcixcbiAgICAgICAgICAgIGNoYXJ0RWRpdG9yLFxuICAgICAgICAgICAgY2hhcnREYXNoYm9hcmRcbiAgICAgICAgfSk7XG4gICAgfSwgW10pO1xuICAgIHVzZUdvb2dsZUNoYXJ0RGF0YVRhYmxlKHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIGdvb2dsZUNoYXJ0V3JhcHBlcixcbiAgICAgICAgZ29vZ2xlQ2hhcnREYXNoYm9hcmRcbiAgICB9KTtcbiAgICBjb25zdCByZW5kZXJDaGFydCA9ICgpPT57XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgb3B0aW9ucywgc3R5bGUsIGNsYXNzTmFtZSwgcm9vdFByb3BzLCBnb29nbGUgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBkaXZTdHlsZSA9IHtcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0IHx8IG9wdGlvbnMgJiYgb3B0aW9ucy5oZWlnaHQsXG4gICAgICAgICAgICB3aWR0aDogd2lkdGggfHwgb3B0aW9ucyAmJiBvcHRpb25zLndpZHRoLFxuICAgICAgICAgICAgLi4uc3R5bGVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAgICBpZDogY2hhcnRJZCxcbiAgICAgICAgICAgIHN0eWxlOiBkaXZTdHlsZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgICAgICAgLi4ucm9vdFByb3BzXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmVuZGVyVG9vbEJhciA9ICgpPT57XG4gICAgICAgIGlmICghcHJvcHMudG9vbGJhckl0ZW1zKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAgICByZWY6IHRvb2xiYXJSZWZcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMsIHN0eWxlIH0gPSBwcm9wcztcbiAgICBjb25zdCBkaXZTdHlsZSA9IHtcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQgfHwgb3B0aW9ucyAmJiBvcHRpb25zLmhlaWdodCxcbiAgICAgICAgd2lkdGg6IHdpZHRoIHx8IG9wdGlvbnMgJiYgb3B0aW9ucy53aWR0aCxcbiAgICAgICAgLi4uc3R5bGVcbiAgICB9O1xuICAgIC8vIElmIHJlbmRlciBwcm9wIGlzIHByb3ZpZGVkLCBnaXZlIHRoZSB1c2VyIGZ1bGwgY29udHJvbCBvdmVyIHRoZSByZW5kZXJpbmcgYnkgcGFzc2luZyByZW5kZXJDaGFydCwgcmVuZGVyQ29udHJvbCBhbmQgcmVuZGVyVG9vbGJhciBmdW5jdGlvbnNcbiAgICBpZiAocHJvcHMucmVuZGVyKSB7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICAgICAgcmVmOiBkYXNoYm9hcmRSZWYsXG4gICAgICAgICAgICBzdHlsZTogZGl2U3R5bGVcbiAgICAgICAgfSwgLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgICAgIHJlZjogdG9vbGJhclJlZixcbiAgICAgICAgICAgIGlkOiBcInRvb2xiYXJcIlxuICAgICAgICB9KSwgcHJvcHMucmVuZGVyKHtcbiAgICAgICAgICAgIHJlbmRlckNoYXJ0LFxuICAgICAgICAgICAgcmVuZGVyQ29udHJvbCxcbiAgICAgICAgICAgIHJlbmRlclRvb2xiYXI6IHJlbmRlclRvb2xCYXJcbiAgICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICAgICAgcmVmOiBkYXNoYm9hcmRSZWYsXG4gICAgICAgICAgICBzdHlsZTogZGl2U3R5bGVcbiAgICAgICAgfSwgcmVuZGVyQ29udHJvbCgocGFyYW0pPT57XG4gICAgICAgICAgICBsZXQgeyBjb250cm9sUHJvcCB9ID0gcGFyYW07XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbFByb3AuY29udHJvbFBvc2l0aW9uICE9PSBcImJvdHRvbVwiO1xuICAgICAgICB9KSwgcmVuZGVyQ2hhcnQoKSwgcmVuZGVyQ29udHJvbCgocGFyYW0pPT57XG4gICAgICAgICAgICBsZXQgeyBjb250cm9sUHJvcCB9ID0gcGFyYW07XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbFByb3AuY29udHJvbFBvc2l0aW9uID09PSBcImJvdHRvbVwiO1xuICAgICAgICB9KSwgcmVuZGVyVG9vbEJhcigpKTtcbiAgICB9XG59O1xuXG5jb25zdCBDaGFydENvbnRleHQgPSAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUNvbnRleHQoY2hhcnREZWZhdWx0UHJvcHMpO1xuY29uc3QgQ29udGV4dFByb3ZpZGVyID0gKHBhcmFtKT0+e1xuICAgIGxldCB7IGNoaWxkcmVuLCB2YWx1ZSB9ID0gcGFyYW07XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDaGFydENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSwgY2hpbGRyZW4pO1xufTtcblxuLyoqXG4gKiBMb2FkcyBHb29nbGUgQ2hhcnRzIEpTIGFuZCByZW5kZXJzIHRoZSBHb29nbGVDaGFydCBjb21wb25lbnQuXG4gKi8gY29uc3QgQ2hhcnRWaWV3ID0gKHByb3BzKT0+e1xuICAgIGNvbnN0IHsgZ29vZ2xlLCBpc0xvYWRpbmcsIGVycm9yIH0gPSB1c2VMb2FkR29vZ2xlQ2hhcnRzKHByb3BzKTtcbiAgICBpZiAoaXNMb2FkaW5nKSB7XG4gICAgICAgIHJldHVybiBwcm9wcy5sb2FkZXIgPz8gbnVsbDtcbiAgICB9XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBwcm9wcy5lcnJvckVsZW1lbnQgPz8gbnVsbDtcbiAgICB9XG4gICAgaWYgKGdvb2dsZSkge1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEdvb2dsZUNoYXJ0LCB7XG4gICAgICAgICAgICBnb29nbGU6IGdvb2dsZSxcbiAgICAgICAgICAgIC4uLnByb3BzXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG4vKipcbiAqIFVwZGF0ZXMgdGhlIGNvbnRleHQgd2l0aCB0aGUgcHJvcHMgYW5kIHJlbmRlcnMgQ2hhcnRWaWV3LlxuICovIGNvbnN0IENoYXJ0ID0gKHVzZXJQcm9wcyk9PntcbiAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgICAgLi4uY2hhcnREZWZhdWx0UHJvcHMsXG4gICAgICAgIC4uLnVzZXJQcm9wc1xuICAgIH07XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChDb250ZXh0UHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHByb3BzXG4gICAgfSwgLyojX19QVVJFX18qLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KENoYXJ0VmlldywgcHJvcHMpKTtcbn07XG5cbi8vIENvbXBsZXRlIEdvb2dsZSBDaGFydHMgVHlwZSBEZWZpbml0aW9uIDogaHR0cHM6Ly9naXRodWIuY29tL0RlZmluaXRlbHlUeXBlZC9EZWZpbml0ZWx5VHlwZWQvYmxvYi9tYXN0ZXIvdHlwZXMvZ29vZ2xlLnZpc3VhbGl6YXRpb24vaW5kZXguZC50c1xudmFyIEdvb2dsZURhdGFUYWJsZUNvbHVtblJvbGVUeXBlO1xuKGZ1bmN0aW9uKEdvb2dsZURhdGFUYWJsZUNvbHVtblJvbGVUeXBlKSB7XG4gICAgR29vZ2xlRGF0YVRhYmxlQ29sdW1uUm9sZVR5cGVbXCJhbm5vdGF0aW9uXCJdID0gXCJhbm5vdGF0aW9uXCI7XG4gICAgR29vZ2xlRGF0YVRhYmxlQ29sdW1uUm9sZVR5cGVbXCJhbm5vdGF0aW9uVGV4dFwiXSA9IFwiYW5ub3RhdGlvblRleHRcIjtcbiAgICBHb29nbGVEYXRhVGFibGVDb2x1bW5Sb2xlVHlwZVtcImNlcnRhaW50eVwiXSA9IFwiY2VydGFpbnR5XCI7XG4gICAgR29vZ2xlRGF0YVRhYmxlQ29sdW1uUm9sZVR5cGVbXCJlbXBoYXNpc1wiXSA9IFwiZW1waGFzaXNcIjtcbiAgICBHb29nbGVEYXRhVGFibGVDb2x1bW5Sb2xlVHlwZVtcImludGVydmFsXCJdID0gXCJpbnRlcnZhbFwiO1xuICAgIEdvb2dsZURhdGFUYWJsZUNvbHVtblJvbGVUeXBlW1wic2NvcGVcIl0gPSBcInNjb3BlXCI7XG4gICAgR29vZ2xlRGF0YVRhYmxlQ29sdW1uUm9sZVR5cGVbXCJzdHlsZVwiXSA9IFwic3R5bGVcIjtcbiAgICBHb29nbGVEYXRhVGFibGVDb2x1bW5Sb2xlVHlwZVtcInRvb2x0aXBcIl0gPSBcInRvb2x0aXBcIjtcbiAgICBHb29nbGVEYXRhVGFibGVDb2x1bW5Sb2xlVHlwZVtcImRvbWFpblwiXSA9IFwiZG9tYWluXCI7XG59KShHb29nbGVEYXRhVGFibGVDb2x1bW5Sb2xlVHlwZSB8fCAoR29vZ2xlRGF0YVRhYmxlQ29sdW1uUm9sZVR5cGUgPSB7fSkpO1xuXG5leHBvcnQgeyBDaGFydCwgR29vZ2xlRGF0YVRhYmxlQ29sdW1uUm9sZVR5cGUsIENoYXJ0IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-google-charts/dist/index.js\n");

/***/ })

};
;